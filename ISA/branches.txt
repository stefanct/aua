jmp und rjmp gibt's derzeit in der ISA, haben 6-stelligen Opcode, sind uns also "wurscht" und bleiben (hier) auf jeden Fall. kleiner und größer/gleich werden hier beide verwendet, wird aber eher in ASM gelöst, also kann man sich als Operations wegdenken oder so.


***************************************************************
* derzeit: breqz, brnez mit imm, mehrere Compare-Instructions *
***************************************************************

Mehrere 6-stellige Opcodes für Vergleiche. Ergebnis wird in ein Register geschrieben als true/false und dann jumps, die auf 0/1 prüfen.

Beispiel: (Vergleich true -> Register 0)

01 cmp_less_than r1 r2
02 breqz 42
03 ... -- Code, wenn Bedingung false
...
42 ... -- Code, wenn Bedingung true

Bedingung erfüllt: 01, 02, 42 (erste "richtige" Instruction), ein Jump.
Bedingung nicht erfüllt: 01, 02, 03 (erste "richtige), kein Jump.

3 Register-Vergleich:

r1 < r2 && r2 > r3

01 cmp_less_than r1 r2
02 brnez 42 -- (1)
03 cmp_less_than r2 r3
04 breqz 42
05 ... -- Code, wenn die Bedingung insgesamt true ist
... 
42 ... -- Code, wenn die Bedingung gesamt false ist

Kompletter Ausdruck true: 01, 02, 03, 04, 42 (erste "richtige"), ein Jump.
Erster Ausdruck false: 01, 02, 42, ein Jump.
Erster Ausdruck true, zweiter false: 01, 02, 03, 04, 05, kein Jump.

(1) Ich will nicht weit springen, wenn die Condition true is' - da will ich ja die zweite Bedingung auswerten erst. Sonst hätte ich hier den Code, falls die komplette Bedingung false ist und vergleich erst dahinter weiter... das wäre ur schiach. Also invertierte Logik.

Leider viele Schritte.

Op-Codes:

breqz, brnez benötigen zwei 3er Opcodes, also viel Platz. (= 16 6er). Einzelne Vergleiche brauchen 6er, also nicht so schlimm, wenn's mehrere gibt. brnez könnte man sich eigentlich sparen? Ist nur dazu da, damit man entscheiden kann, ob man bei true oder false im Code weitergeht bzw. wegspringt. Könnte man auch mit invertierter Logik erreichen, das lässt sich vom Assembler sogar lösen. Dann wäre nur noch ein branch notwendig, was einen kompletten 3-er Opcode freigibt. Evtl. eher noch einen zusätzlichen Branch, der ein Register statt imm nimmt? Wäre 6-stelliger Opcode möglich, da zwei Register als Argumente, also nicht so tragisch.

************************************************
* viele 1-step-branches + ein "richtiges" jump *
************************************************

breqz, brnez fliegen raus, haben einen 3-stelligen Opcode, machen also viel Platz. Stattdessen kommt ein zusaetzlicher jump mit imm ins Spiel. Der Branch hat keine Condition, somit als einziges Argument die imm, die selbst bei 6-stelligem Opcode 10-stellig ausfallen koennte.
Compare und branch fällt zusammen und besteht aus zwei zu vergleichenden Registern und einem Opcode (somit 6-stellig). Ist der Vergleich erfüllt, wird die nächste Instruction übersprungen. Die nächste Instruction ist ein jump.

Beispiel:

01 cmp_less_than r1, r2 -- ist r1 kleiner als r2? Wenn ja, in Zeile 03 springen
02 jump 42 -- r1 war wohl nicht kleiner, jump nach 42
03 ...

Ist der Vergleich erfüllt, ist die nächste Instruction nach dem Vergleich der weitere Code. Andernfalls ist ein zusätzlicher jump notwendig.

3 Register-Vergleich:

r1 < r2 && r2 > r3

01 cmp_less_than r1 r2
02 jump 42
03 cmp_greater_than r2 r3
04 jump 42
05 ... -- Code, wenn Bedingung erfüllt
...
42 ... -- Code, wenn Bedingung nicht erfüllt

Ist die komplette Bedingung true, werden 01, 03, 05 ausgeführt, wobei 05 schon der erste "richtige" Code nach der Bedingung ist. Zwei 1-step-jumps notwendig.

Ist schon die erste Teilbedingung false, werden 01, 02 und 42 ausgeführt, 42 wieder als erste "richtige" Instruction. Nur ein jump notwendig.

Ist erst die zweite Teilbedingung falsch, werden 01, 03, 04, 42 ausgeführt - ein 1-step-jump + ein richtiger jump.

Op-Codes:

breqz, brnez machen Platz für 16 6-stellige Op-Codes. Der jump mit imm ist 6-stellig, die Vergleiche ebenfalls. Theoretisch wäre erst mit 15 Vergleichen der selbe Platz belegt. Besser allerdings zwei 6-stellige jumps: relativ und absolut.


********************************
* compare mit eigenem Register *
********************************

breqz, brnez fliegen raus. Ein compare für zwei Register (6-stelliger Opcode), Ergebnis wird in das Register geschrieben. Problempunkt: es werden unnötig viele Vergleiche gleichzeitig gemacht (alle möglichen) und die Ergebnisse in das Register geschrieben. Ist das egal? Ich weiß es nicht. Es gibt eine Reihe an jump-Befehlen, die die verschiedenen Bits im compare register abfragen.
Auf jeden Fall werden zwei Schritte benötigt. Das compare wird durchgeführt und beim jump wird ein Bit abgefragt und evtl. gesprungen.

Beispiel:

01 cmp r1 r2
02 jump_if_less_than 42 -- r1 < r2 ? Dann zu 42.
03 ... -- r1 >= r2
...
42 -- r1 < r2

Vergleich erfüllt: 01, 02, 42 (erste "richtige" Instruction), ein Jump.
Nicht erfüllt: 01, 02, 03 - kein jump.

3 Register-Vergleich

r1 < r2 && r2 > r3

01 cmp r1 r2
02 jump_if_greater_equal 42 -- (1)
03 cmp r2 r3
04 jump_if_less_equal 42
05 ... -- Code, wenn Bedingung true
...
42 ... -- Code, wenn Bedingung false

Vergleich erfüllt: 01, 02, 03, 04, 05 (erste "richtige" Instruction), kein Jump. Bäh.
Nicht erfüllt: 01, 02, 42 (erste "richtige"), ein Jump.

(1) Ist der Vergleich erfüllt, wird gesprungen. Es soll allerdings noch ein zweiter Vergleich durchgeführt werden, der passt im Code besser drunter. So kann bei beiden Teilvergleichen gleich zur Adresse gesprungen werden, für den Code, falls die gesamte Bedingung false ist.
Diese invertierte Logik gefällt mir nicht.

Op-Codes:

breqz, brnez machen wieder Platz für 16 6er-Opcodes. Compare braucht einen, Jumps brauchen den Rest. Falls wieder relativ und absolute Adresse für jumps, braucht man gleich die doppelte Anzahl, auch nicht so optimal.

